"""
简单的自动曝光
问题描述
给定一个长度为n 的整数数组img，表示一张图像的像素值，每个像素值的范围是[0,255] 的整数。
现在需要给每个像素值加上一个整数k（可以是负数），得到新的图像newImg，使得newImg 中所有像
素的平均值最接近中位值 128。请计算并输出这个整数k。

输入格式
一行n 个整数，用空格分隔，表示原图像img 的像素值。

输出格式
一个整数k。

样例输入
样例 1
0 0 0 0
样例 2
129 130 129 130
样例输出
样例 1
128
样例 2
-2
样例解释
样例 1
原图像的四个像素值都为 0，加上 128 后，新图像的所有像素值变为 128，平均值正好是 128。

样例 2
当k=−1 时，新图像为 128 129 128 129，平均值为 128.5。
当k=−2 时，新图像为 127 128 127 128，平均值为 127.5。
两种情况下，127.5 更接近 128，且-2 小于 -1，所以输出 -2。
"""

def find_best_k(img):
    # 计算原图像的平均值
    mean_img = sum(img) / len(img)

    # 计算最优的 k
    k = round(128 - mean_img)

    return k

# 输入
img = list(map(int, "129 130 129 130".split()))

# 输出结果
print(find_best_k(img))
