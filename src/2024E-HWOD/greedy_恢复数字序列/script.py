"""
题目描述

对于一个连续正整数组成的序列，可以将其拼接成一个字符串，再将字符串里的部分字符打乱顺序。
如序列8 9 10 11 12,拼接成的字符串为89101112,打乱一部分字符后得到90811211,原来的正整数10
就被拆成了0和1。

现给定一个按如上规则得到的打乱字符的字符串，请将其还原成连续正整数序列，并输出序列中最小
的数字。

输入描述
输入一行，为打乱字符的字符串和正整数序列的长度，两者间用空格分隔，字符串长度不超过200,正
整数不超过1000,保证输入可以还原成唯一序列。

输出描述
输出一个数字，为序列中最小的数字。

用例

输入
19801211 5
输出
8
"""
def restore_sequence(s: str, length: int) -> int:
    """
    还原打乱的字符序列，并找到最小的数字。
    """
    # 因为是“连续正整数数组”所以可以暴力搜索
    # 遍历可能的起始数字范围，通过长度确定原始序列的范围
    for start in range(1, 10000):
        # 构建从 start 开始的连续整数序列
        sequence = ''.join(map(str, range(start, start + length)))

        # 如果打乱的字符串与该序列匹配
        if sorted(sequence) == sorted(s):
            return start  # 找到最小的数字

    return -1  # 如果没有找到合适的起点，返回错误标志

# 示例输入
s, length = "19801211", 5
print(restore_sequence(s, length))  # 输出 8

