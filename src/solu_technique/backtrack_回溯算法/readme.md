回溯算法和 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的
细微差别是：回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」。

抽象地说，解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合
法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。

站在回溯树的一个节点上，你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。


回溯算法的框架：
```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        #做选择
        选择列表.remove(选择)
        路径.add(选择)
        backtrack(路径, 选择列表)
        #撤销选择
        路径.remove(选择)
        选择列表.add(选择)
```

backtrack中如何遍历一棵树？多叉树的遍历框架：
```python
def traverse(root):
    for child in root.children:
        do_preorder_stuff()         # 此处是前序位置需要的操作
        traverse(child)
        do_postorder_stuff()        # 此处是后序位置需要的操作
```

DFS中如何遍历一棵树？多叉树的遍历框架：
```python
def traverse(root):
    do_preorder_stuff()         # 此处是前序位置需要的操作
    for child in root.children:
        traverse(child)
    do_postorder_stuff()        # 此处是后序位置需要的操作
```

而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点:
- 前序遍历的代码在进入某一个节点之前的那个时间点执行，
- 后序遍历代码在离开某个节点之后的那个时间点执行。

例如上文所述backtrack中，「路径」和「选择」是每个节点的属性，函数在树上游走要正确处理节
点的属性，其实就是要在这两个特殊时间点搞点动作：
- 在到达子节点之前“做选择”，
- 在离开子节点之后“撤销选择”。（维护选择列表完整性）


