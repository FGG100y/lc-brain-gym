"""
力扣岛屿数量问题：

-  200. 岛屿数量
- 1254. 统计封闭岛屿的数目
"""
#  200. 岛屿数量
#  -------------
#  给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
#
#  岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
#
#  此外，你可以假设该网格的四条边均被水包围。
#
#  示例 1：
#  输入：grid = [
#    ["1","1","1","1","0"],
#    ["1","1","0","1","0"],
#    ["1","1","0","0","0"],
#    ["0","0","0","0","0"]
#  ]
#  输出：1
#
#  示例 2：
#  输入：grid = [
#    ["1","1","0","0","0"],
#    ["1","1","0","0","0"],
#    ["0","0","1","0","0"],
#    ["0","0","0","1","1"]
#  ]
#  输出：3

#  1254. 统计封闭岛屿的数目
#  ------------------------
#  二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封
#  闭岛是一个 完全 由1包围（左、上、右、下）的岛。
#
#  请返回 封闭岛屿 的数目。
#
#  示例 1：
#  输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],
#  [1,1,1,1,1,1,1,0]]
#  输出：2
#  解释：
#  灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
#
#  示例 2：
#  输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
#  输出：1
#
#  示例 3：
#  输入：grid = [[1,1,1,1,1,1,1],
#               [1,0,0,0,0,0,1],
#               [1,0,1,1,1,0,1],
#               [1,0,1,0,1,0,1],
#               [1,0,1,1,1,0,1],
#               [1,0,0,0,0,0,1],
#               [1,1,1,1,1,1,1]]
#  输出：2



#  200. 岛屿数量
def islands_num(mat):
    rows, cols = len(mat), len(mat[0])
    ans = 0

    def dfs(x, y):                          # (x, y) coordinates in matrix
        # 如果不满足条件，递归返回
        if not (0 <= x < rows) or not (0 <= y < cols) or mat[x][y] == "0":
            return
        mat[x][y] = -1                      # 将节点标记为-1（表示已访问）
        # 开始从四个方向递归
        dfs(x+1, y)
        dfs(x-1, y)
        dfs(x, y+1)
        dfs(x, y-1)

    for i in range(rows):
        for j in range(cols):
            if mat[i][j] == "1":            # 碰上陆地就更新计数器
                ans += 1
                dfs(i, j)                   # 这个函数会把陆地格子全变成-1
    return ans


#  1254. 统计封闭岛屿的数目
def closed_islands_num(mat):
    rows, cols = len(mat), len(mat[0])
    ans = 0

    def dfs(x, y):
        if not (0 <= x < rows and 0 <= y < cols):       # 递归终止1:在边界上
            return False
        if mat[x][y] != 0:                              # 递归终止2:不是陆地格子
            return True

        mat[x][y] = -1

        ret1 = dfs(x+1, y)
        ret2 = dfs(x-1, y)
        ret3 = dfs(x, y+1)
        ret4 = dfs(x, y-1)

        return ret1 and ret2 and ret3 and ret4          # 看下一个注释就明白了

    for i in range(rows):
        for j in range(cols):
            if mat[i][j] == 0 and dfs(i, j):            # 碰上陆地且被水包围住
                ans += 1
    return ans
